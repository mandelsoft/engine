package db

import (
	"encoding/json"

	"github.com/mandelsoft/engine/pkg/processing"
	"github.com/mandelsoft/engine/pkg/processing/model"
	"github.com/mandelsoft/goutils/jsonutils"
	"github.com/mandelsoft/logging"
)

////////////////////////////////////////////////////////////////////////////////
// Simple slaves
////////////////////////////////////////////////////////////////////////////////

type SlaveStateSpec interface {
	ApplyFormalObjectVersion(log logging.Logger, state model.ExternalState, t TargetState, mod *bool) bool
}

// DefaultSlaveStateSpec is a default implementation
// for the object spec extension used by a state
// objects for objects used as slave.
// Such external objects are always used in two modes,
// as slave (generated by another phase) or as user
// provided object.
// As user provided object, they feature their own
// links (typically none). As slave, they always depend
// on their providing phase.
// This information is stored in a state extension provided
// by its state object, It typically just described the
// provider.
// Based on the used mode, the formal object version
// must be handled differently. For user provided objects
// the formal version calculated from the spec of the external
// object. For slave objects, the object formal object version
// is completely determined by the outputs of its
// providing phase (typically the inputs used by the state object).
// This is implemented by an empty formal object version.
type DefaultSlaveStateSpec struct {
	Provider string `json:"provider,omitempty"`
}

func (s *DefaultSlaveStateSpec) ApplyFormalObjectVersion(log logging.Logger, state model.ExternalState, t TargetState, mod *bool) bool {
	m := false
	if s.Provider != "" {
		m = t.SetFormalObjectVersion("")
		if m {
			log.Info("formal object version voided for slave of {{provider}}", "provider", s.Provider)
		}
	} else {
		formal := state.GetVersion()
		m = t.SetFormalObjectVersion(formal)
		if m {
			log.Info("formal object version updated from spec {{formal}}", "formal", formal)
		}
	}
	if m && mod != nil {
		*mod = true
	}
	return m
}

type SlaveStateSpecPointer[P any] interface {
	SlaveStateSpec
	*P
}

// StandardEffectiveSlaveObjectSpec describes the effective object
// specification provided by a state object for an external
// object potentially usable as slave. It consists
// of the spec of the external object plus an extension
// provided by the state object to keep the provider
// (see DefaultSlaveStateSpec).
type StandardEffectiveSlaveObjectSpec[S any, E any, P SlaveStateSpecPointer[E]] struct {
	External  *S `json:",inline"`
	Extension E  `json:",inline"`
}

func NewStandardEffectiveSlaveObjectSpec[S any, E any, P SlaveStateSpecPointer[E]](s *S, e E) *StandardEffectiveSlaveObjectSpec[S, E, P] {
	return &StandardEffectiveSlaveObjectSpec[S, E, P]{
		Extension: e,
		External:  s,
	}
}

var (
	_ json.Marshaler   = StandardEffectiveSlaveObjectSpec[any, DefaultSlaveStateSpec, *DefaultSlaveStateSpec]{}
	_ json.Unmarshaler = (*StandardEffectiveSlaveObjectSpec[any, DefaultSlaveStateSpec, *DefaultSlaveStateSpec])(nil)
)

type t[S any, E any, P SlaveStateSpecPointer[E]] StandardEffectiveSlaveObjectSpec[S, E, P]

func (s StandardEffectiveSlaveObjectSpec[S, E, P]) MarshalJSON() ([]byte, error) {
	return jsonutils.MarshalStruct(&s)
}

func (s *StandardEffectiveSlaveObjectSpec[S, E, P]) UnmarshalJSON(data []byte) error {
	return jsonutils.UnmarshalStruct(data, s)
}

func (s *StandardEffectiveSlaveObjectSpec[S, E, P]) ApplyFormalObjectVersion(log logging.Logger, t TargetState, mod *bool) bool {
	return P(&s.Extension).ApplyFormalObjectVersion(log, processing.NewState(s.External), t, mod)
}

type DefaultEffectiveSlaveObjectSpec[S any] struct {
	StandardEffectiveSlaveObjectSpec[S, DefaultSlaveStateSpec, *DefaultSlaveStateSpec] `json:",inline"`
}

func NewDefaultEffectiveSlaveObjectSpec[S any](s *S, ext *DefaultSlaveStateSpec) *DefaultEffectiveSlaveObjectSpec[S] {
	return &DefaultEffectiveSlaveObjectSpec[S]{
		*NewStandardEffectiveSlaveObjectSpec(s, *ext),
	}
}

////////////////////////////////////////////////////////////////////////////////
// Foreign controlled
////////////////////////////////////////////////////////////////////////////////

type ForeignControlledExternalObjectSpec interface {
	GetSpecVersion() string
	IsReached() bool
}

// DefaultForeignControlledExternalObjectSpec is the formal spec used from an
// foreign controlled external object. Because this object is foreign controlled,
// it not only consists of the spec of the external object (as usual),
// but of selected status fields, also.
// This must at least be the outcome of the foreign processing and information
// required to detect, whether the actual spec has already been applied.
type DefaultForeignControlledExternalObjectSpec[S any, O any] struct {
	Spec            S            `json:"spec"`
	Status          model.Status `json:"status"`
	Message         string       `json:"message"`
	ObservedVersion string       `json:"observervedVersion"`
	Output          O            `json:"output"`
}

func (s *DefaultForeignControlledExternalObjectSpec[S, O]) GetSpecVersion() string {
	return processing.NewState(&s.Spec).GetVersion()
}

func (s *DefaultForeignControlledExternalObjectSpec[S, O]) IsReached() bool {
	return processing.NewState(&s.Spec).GetVersion() == s.ObservedVersion
}
