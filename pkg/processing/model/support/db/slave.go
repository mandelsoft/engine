package db

import (
	"github.com/mandelsoft/engine/pkg/processing"
	"github.com/mandelsoft/engine/pkg/processing/model"
	"github.com/mandelsoft/logging"
)

////////////////////////////////////////////////////////////////////////////////
// Simple slaves
////////////////////////////////////////////////////////////////////////////////

type SlaveStateSpec interface {
	ApplyFormalObjectVersion(log logging.Logger, state model.ExternalState, t TargetState, mod *bool) bool
}

// DefaultSlaveStateSpec is a default implementation
// for the object spec extension used by a state
// objects for objects used as slave.
// Such external objects are always used in two modes,
// as slave (generated by another phase) or as user
// provided object.
// As user provided object, they feature their own
// links (typically none). As slave, they always depend
// on their providing phase.
// This information is stored in a state extension provided
// by its state object, It typically just described the
// provider.
// Based on the used mode, the formal object version
// must be handled differently. For user provided objects
// the formal version calculated from the spec of the external
// object. For slave objects, the object formal object version
// is completely determined by the outputs of its
// providing phase (typically the inputs used by the state object).
// This is implemented by an empty formal object version.
type DefaultSlaveStateSpec struct {
	Provider string `json:"provider,omitempty"`
}

func (s *DefaultSlaveStateSpec) ApplyFormalObjectVersion(log logging.Logger, state model.ExternalState, t TargetState, mod *bool) bool {
	m := false
	if s.Provider != "" {
		m = t.SetFormalObjectVersion("")
		if m {
			log.Info("formal object version voided for slave of {{provider}}", "provider", s.Provider)
		}
	} else {
		formal := state.GetVersion()
		m = t.SetFormalObjectVersion(formal)
		if m {
			log.Info("formal object version updated from spec {{formal}}", "formal", formal)
		}
	}
	if m && mod != nil {
		*mod = true
	}
	return m
}

// EffectiveSlaveObjectSpec describes the effective object
// specification provided by a state object for an external
// objects potentially usable as slave. It consists
// of the spec of the extenal object plus an extension
// provided by the state object to keep the provider
// (see DefaultSlaveStateSpec).
type EffectiveSlaveObjectSpec[S any, E SlaveStateSpec] struct {
	Spec      *S
	Extension E
}

func (s *EffectiveSlaveObjectSpec[S, E]) ApplyFormalObjectVersion(log logging.Logger, t TargetState, mod *bool) bool {
	return s.Extension.ApplyFormalObjectVersion(log, processing.NewState(s.Spec), t, mod)
}

////////////////////////////////////////////////////////////////////////////////
// Foreign controlled
////////////////////////////////////////////////////////////////////////////////

type ForeignControlledExternalObjectSpec interface {
	GetSpecVersion() string
	IsReached() bool
}

// DefaultForeignControlledExternalObjectSpec is the formal spec used from an
// foreign controlled external object. Because this object is foreign controlled,
// it not only consists of the spec of the external object (as usual),
// but of selected status fields, also.
// This must at least be the outcome of the foreign processing and information
// required to detect, whether the actual spec has already been applied.
type DefaultForeignControlledExternalObjectSpec[S any, O any] struct {
	Spec            S            `json:"spec"`
	Status          model.Status `json:"status"`
	Message         string       `json:"message"`
	ObservedVersion string       `json:"observervedVersion"`
	Output          O            `json:"output"`
}

func (s *DefaultForeignControlledExternalObjectSpec[S, O]) GetSpecVersion() string {
	return processing.NewState(&s.Spec).GetVersion()
}

func (s *DefaultForeignControlledExternalObjectSpec[S, O]) IsReached() bool {
	return processing.NewState(&s.Spec).GetVersion() == s.ObservedVersion
}
